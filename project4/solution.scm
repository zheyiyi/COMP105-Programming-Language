;; Comp105 scheme assignment

;; You will be implementing these functions.
(check-expect (procedure? count) #t)
(check-expect (procedure? countall) #t)
(check-expect (procedure? mirror) #t)
(check-expect (procedure? flatten) #t)
(check-expect (procedure? contig-sublist?) #t)
(check-expect (procedure? sublist?) #t)
(check-expect (procedure? takewhile) #t)
(check-expect (procedure? dropwhile) #t)
(check-expect (procedure? take) #t)
(check-expect (procedure? drop) #t)
(check-expect (procedure? zip) #t)
(check-expect (procedure? unzip) #t)
(check-expect (procedure? arg-max) #t)
(check-expect (procedure? merge) #t)
(check-expect (procedure? interleave) #t)
(check-expect (procedure? remove-one-copy) #t)
(check-expect (procedure? permutation?) #t)
(check-expect (procedure? split-list) #t)

;; note to staff: template headers generated by `template-header`

eck-expect (=edge-list? '((A B) (B C) (A C)) '(A B)) #t)
(check-expect (=edge-list? '((A B) (B C) (A C)) '(B C)) #t)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Problem 2a
;;
;; (count x xs) returns the number of (top-level) elements of xs
;; that equal to x where x is an atom and xs is in LIST(SEXPi),
;; otherwise, returns 0 if xs is null 

(check-expect (count '# '()) 0) ;;test the case where xs is null 
(check-expect (count '# '(1 b b a)) 0) ;;test the case with zero of x 
(check-expect (count 'a '(1 a b a a c a)) 4) ;;test the case with multiple x   
(check-expect (count 'a '(1 a ((a () (a))))) 1) ;;test the case with all 
;; levels  
(check-expect (count '(a b) '(1 b (a b) a #)) 0) ;;test with case where x
;;  is a list    


(define count (x xs)
  (if (null? xs)
    0
    (if (= x (car xs)) 
      (+ 1 (count x (cdr xs)))
      (+ 0 (count x (cdr xs))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Problem 2b
;; 
;; (countall x xs) returns the number of times x occurs anywhere 
;; in xs, where x is an atom and xs is in LIST(SEXP), otherwise
;; returns 0 if xs is null  

(check-expect(countall '# '()) 0) ;;test the case where xs is null 
(check-expect(countall '# '(1 b b a)) 0) ;;test the case with zero of x 
(check-expect(countall 'a '(1 a b a a c a)) 4) ;;test the case with multiple x  
(check-expect(countall 'a '(1 b a (c () (((a)))))) 2) ;;test the case with all
;; levels  
(check-expect(countall 'a '(1 b a (c a) (a a a) (c b a))) 6) ;;test the case
;; with all levels  
(check-expect(countall '(a b) '(1 b (a b) a #)) 0) ;;test with case 
;; where x is a list  


(define countall (x xs)
  (if (null? xs)
    0
    (if (pair? (car xs))
      (+ (countall x (cdr xs)) (countall x (car xs)))
      (if (= x (car xs))
        (+ 1 (countall x (cdr xs)))
        (+ 0 (countall x (cdr xs))))))) 



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Problem 2c
;;
;; (mirror xs) returns a list in which every list in xs is recursively
;; mirrored, and the resulting lists are in reverse order, where xs is
;; a list of S-expression, otherwise returns '() if xs is null


(check-expect (mirror '()) '()) ;;tests the case where xs is null
(check-expect (mirror '(a b c d)) '(d c b a)) ;;tests the case where xs is 
;; a single list with one level
(check-expect (mirror '(a (b c) c d)) '(d c (c b) a)) ;;tests the case where
;; xs is a list with mutiple levels
(check-expect (mirror '(a (b (a (g h) e) c) c d)) '(d c (c (e (h g) a) b) a))
;;tests the case where xs is a list with complicated mutiple levels


(define mirror (xs)
  (if (null? xs)
    '()
    (if (pair? xs)
      (append (mirror (cdr xs)) (list1 (mirror (car xs))))
      xs)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Problem 2d
;;
;; (flatten xs) returns a list having the same atoms as xs in the
;; same order but in a flat list, where xs is a list of S-expression,
;; otherwise, returns 0 if xs is null  

(check-expect (flatten '()) '()) ;; test the case with null xs           
(check-expect (flatten '(a b c d)) '(a b c d)) ;;test the case with 
(check-expect (flatten '((I Ching) (U Thant) (Coli))) '(I Ching U Thant Coli))
;;tests the case where xs contain different lists


;one element test
(check-expect (flatten '((((a))))) '(a))                    
;;multiple inner lists test
(check-expect (flatten '((a b) ((c d) e))) '(a b c d e)) ;;flatten empty list
(check-expect (flatten '(1 () (2 4))) '(1 2 4))
(define flatten (xs)
  (if (null? xs)    
    '()
    (if (pair? xs)
      (append (flatten (car xs)) (flatten (cdr xs)))
      (list1 xs))))
  

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Problem 2e
;;
;; (contig-sublist? xs ys) returns #t if all the elements in xs 
;; are included in ys in the same contiguous order, where both
;; xs and ys are in set LIST(ATOM), returns #t if xs is null,
;; otherwise returns #f if ys is null 

(check-expect (contig-sublist? '() '(x a y b z c)) #t) ;; tests the case where
;; xs is null
(check-expect (contig-sublist? '(a y b) '()) #f) ;; tests the case where ys is
;; null
(check-expect (contig-sublist? '() '()) #t) ;; tests the case where both xs and
;; ys are null
(check-expect (contig-sublist? '(x) '(x a y b z c)) #t) ;; tests the case 
;; where xs is only one element which is included in the ys 
(check-expect (contig-sublist? '(a y b) '(x a y b z c)) #t) ;; tests the case 
;; where xs are included in the ys in the same contiguous order
(check-expect (contig-sublist? '(a b c) '(x a y b z c)) #f) ;; tests the case 
;; where xs are included in the ys in the same order but not contiguous
(check-expect (contig-sublist? '(a b c d e f g h i g k) '(x a y)) #f) ;; tests 
;; the case where 


;; (contig-same xs ys) returns #t if all the elements in xs is 
;; included in ys in the same contiguous order


(check-expect (contig-same? '(x) '(x a y b z c)) #t) ;; tests the case 
;; where xs is only one element which is included in the ys 
(check-expect (contig-same? '(a b c) '(x a y b z c)) #f) ;; tests the case 
;; where xs are included in the ys in the same order but not contiguous
(check-expect (contig-same? '(a b c d e f g h i g k) '(x a y)) #f) ;; tests 
;; the case where xs is longer than ys


(define contig-same? (xs ys)
  (if (null? xs)
    #t
    (if (= (car xs) (car ys))
      (contig-same? (cdr xs) (cdr ys))
      #f)))


(define contig-sublist? (xs ys)
  (if (null? xs)
    #t
    (if (null? ys)
      #f
      (if (= (car xs) (car ys))
        (contig-same? xs ys)
        (contig-sublist? xs (cdr ys))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Problem 2f
;;
;; (sublist? xs ys) returns #t if and only if the lists ys contains 
;; the elements of xs in the same order but possibly with other values
;; in between, where both xs and ys are in set LIST(ATOM), returns #t 
;; if xs is null, otherwise returns #f if ys is null

(check-expect (sublist? '() '(x a y b z c)) #t) ;;tests the case with null xs
(check-expect (sublist? '(a b c) '()) #f) ;;tests the case with null ys
(check-expect (sublist? '() '()) #t) ;;tests the case with both null xs and ys
(check-expect (sublist? '(a b c) '(x a y b z c)) #t) ;;tests the case where ys
;; contains xs but not in contiguous order
(check-expect (sublist? '(a y b) '(x a y b z c)) #t) ;;tests the case where ys
;; contains xs in contiguous order
(check-expect (sublist? '(a z b) '(x a y b z c)) #f) ;;tests the case where ys
;; contains xs but not in the same order
(check-expect (sublist? '(x y p) '(x a y b z c)) #f)  ;;tests the case where ys
;; doesn't contain xs


(define sublist? (xs ys)
  (if (null? xs)
    #t              
    (if (null? ys)
      #f
      (if (= (car xs) (car ys))
        (sublist? (cdr xs) (cdr ys))
        (sublist? xs (cdr ys))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Problem 10
;;
;; (takewhile p? xs) returns the longest prefix of the list in 
;; which every element satisfies the predicate, where p is a 
;; predicate and xs is a list, otherwise returns '() if xs is null 

(check-expect (takewhile number? '()) '()) ;;test the case where xs is null
(check-expect (takewhile null? '(1 2 3)) '()) ;;test the case where result 
;; is null 
(check-expect (takewhile number? '(1 2 3 8 #t 8 9 6)) '(1 2 3 8)) ;; test the
;; case when part of the result is true


(define takewhile (p? xs)
  (if (null? xs)
    '()
    (if (p? (car xs))
      (cons (car xs) (takewhile p? (cdr xs)))
      '())))


;; (dropwhile p? xs) returns whatever is left over after removing 
;; the longest prefix, where p is a predicate and xs is a list,
;; otherwise returns '() if xs is null

(check-expect (dropwhile null? '(1 2 3)) '(1 2 3)) ;; test the case where 
;; there are no any elemnts in the xs fit the condition
(check-expect (dropwhile number? '(1 2 3)) '()) ;; tests the case where
;; all of elements in xs fit the condition
(check-expect (dropwhile number? '(1 2 3 #t 8  #f 7 3)) '(#t 8 #f 7 3))
;; tests the case where some of elements in xs fit the condition

(define dropwhile (p? xs)
  (if (null? xs)
    '()
    (if (p? (car xs))
      (dropwhile p? (cdr xs))
      (append xs '()))))                           


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Problem 30
;;
;;
;; a) The function vector-length (x y) return square root of (x^2+y^2) where
;; x and y are two integer arguments                                   
;;
;; b) In a let expression, (let ((x1 e1) (x2 e2)...(xn en)) e), all of ei's 
;; are evaluated before any of the xi's are bound.let first evaluate '*' and
;; '+', and then assign '*' to '+' and assign '+' to '*'. This means that the
;; meaning of + changes to * and the meaning of * changes to +. so in the sqrt
;; body, the function * actually do what + does and the function + actually do
;; what * do. Their function change. So the result is the square root of 
;; (x*x + y*y)





;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Problem A (take)
;;
;; (take n xs) returns the longest repfix of xs that contains at 
;; most n elements, where n is a natural number and xs is a list,
;; it returns '() if n is not a natural number, otherwise, it 
;; returns 0 if xs is null

(check-expect (take '$ '(a b c d e f g)) '()) ;;tests the case where n is 
;; a symbol 
(check-expect (take 0 '(a b c d e f g)) '()) ;;tests the case where n is 0
(check-expect (take -11 '(a b c d e f g)) '()) ;; tests the case where n is
;; negative
(check-expect (take 3 '()) '());; test the case where xs is empty
(check-expect (take 100 '(a b c d e f g)) '(a b c d e f g)) ;;tests the case
;; where the number of n is bigger than the number of elements in the xs   
(check-expect (take 3 '(a b c d e f g)) '(a b c)) ;;tests the case where the
;; number of n is smaller than the number of elements in the xs            

(define take (n xs)
  (if (not (number? n))
    '()
    (if (not (> n 0))
      '()
      (if (null? xs)
        '()
        (if (not (> (length xs) n))
          xs
          (cons (car xs) (take (- n 1) (cdr xs))))))))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Problem A (drop)
;;
;; (drop n xs) removes n elements from the front of xs, where xs
;; is a list and n is natural number

(check-expect (drop '$ '(a b c d e f g)) '(a b c d e f g)) ;;tests the case 
;; where n is a symbol  
(check-expect (drop 0 '(a b c d e f g)) '(a b c d e f g)) ;;tests the case
;; where n is 0
(check-expect (drop -11 '(a b c d e f g)) '(a b c d e f g)) ;;tests the case
;; where n is negative
(check-expect (drop 3 '()) '()) ;;tests the case where xs is null
(check-expect (drop 100 '(a b c d e f g)) '(a b c d e f g))  ;;tests the case
;; where the number of n is bigger than the number of elements in the xs     
(check-expect (drop 3 '(a b c d e f g)) '(d e f g))  ;;tests the case where 
;; the number of n is smaller than the number of elements in the xs


(define drop (n xs)
  (if (not (number? n))
    xs    
    (if (not (> n 0))
      xs
      (if (not (> (length xs) n))
        xs
        (drop (- n 1) (cdr xs))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Problem B (zip)
;;
;; (zip xs ys) returns an association list by converting a pair of
;; lists xs and ys, where both xs and ys are lists, otherwises, returns
;; '() if xs or ys  

(check-expect(zip '(1) '()) '());;check the case with null ys
(check-expect(zip '() '(a)) '());;check the case with null xs
(check-expect(zip '()' ()) '()) ;; check the case with both bull
(check-expect(zip '(1) '(a)) '((1 a)));;check the case with only one pair
(check-expect(zip '(1 2 3) '(a b c))'((1 a) (2 b) (3 c)));;check the case 
;; when there are three keys


(define zip (xs ys) 
  (if (or (null? xs) (null? ys)) 
    '()
    (cons (list2 (car xs) (car ys)) (zip (cdr xs) (cdr ys)))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Problem B (unzip)
;;
;; (unzip xs) returns a pair of lists by converting an association
;; list xs, where xs is a list


(check-expect(unzip '()) '()) ;;tests the case where xs is null
(check-expect(unzip '((1 a) (2 b) (3 c))) '((1 2 3) (a b c)));;check the case
;; where there are three pairs
(check-expect(unzip '((3 c))) '((3) (c))) ;;check the case where there is 
;; only one pair


;; (rebuild-fronthalf xs) returns first half of xs, where xs is a list

(check-expect(rebuild-fronthalf '()) '()) ;;tests the case where xs is null
(check-expect(rebuild-fronthalf  '((1 a) (2 b) (3 c))) '(1 2 3));;check the
;; case where there are three pairs
(check-expect(rebuild-fronthalf  '((3 c))) '(3)) ;;check the case where there
;; is only one pair

(define rebuild-fronthalf(xs) 
  (if(null? xs)
    '()
    (cons (caar xs) (rebuild-fronthalf(cdr xs)))))


;; (rebuild-backhalf xs) returns second half of xs, where xs is a list

(check-expect(rebuild-backhalf '()) '()) ;;tests the case where xs is null
(check-expect(rebuild-backhalf  '((1 a) (2 b) (3 c))) '(a b c));;check the
;; case where there are three pairs
(check-expect(rebuild-backhalf  '((3 c))) '(c)) ;;check the case where there
;; is only one pair


(define rebuild-backhalf(xs)
    (if(null? xs)
      '()
      (cons (cadar xs) (rebuild-backhalf(cdr xs)))))


(define unzip (xs) 
    (if (null? xs)
      '()
      (list2 (rebuild-fronthalf xs) (rebuild-backhalf xs))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Problem C
;;
;; (arg-max f as) returns an element a in as for which (f a) is as 
;; large as possible, where f is a function that maps a value in set 
;; A to a number and a nonempty list as of values in set A 


(define invert (a) (/ 1000 a))
(check-expect (arg-max invert '(5 4 3 2 1)) 1) ;;tests the case with invert
(define square (a) (* a a))
(check-expect (arg-max square '(5 4 3 2 1)) 5) ;;tests the case with square


(define arg-max (f as)
  (if (null? as)
    1
    (if (> (f (car as)) (f (arg-max f (cdr as))))
      (car as)      
      (arg-max f (cdr as)))))                                      


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Problem D
;;
;; (merge xs ys) returns a single list sorted in increasing order
;; containing exactly the same elements, where both xs and ys are
;; lists of numbers in increasing order, it returns ys if xs is null
;; otherwise, it returns xs if ys is null 

(check-expect (merge '() '(3 5 6 8 10)) '(3 5 6 8 10)) 
;;tests the case with null xs
(check-expect (merge '(1 4 9) '()) '(1 4 9)) ;; tests the case with null ys
(check-expect (merge '() '()) '())  
;; tests the case with both xs and ys are null
(check-expect (merge '(1 2 3 4 5) '(6 7 8 9 10)) '(1 2 3 4 5 6 7 8 9 10))
;; tests the case with where both xs and ys have the same number of elements
(check-expect (merge '(1 2 4 7 9) '(3 5 10)) '(1 2 3 4 5 7 9 10)) 
;; tests the case with where xs has more elements than ys
(check-expect (merge '(1 4 9) '(3 5 6 8 10)) '(1 3 4 5 6 8 9 10))
;; tests the case with where ys has more elements than xs


(define merge (xs ys)
  (if (null? xs)
    ys
    (if (null? ys)
      xs                                                             
      (if (not (< (car xs) (car ys)))
        (cons (car ys) (merge xs (cdr ys)))
        (cons (car xs) (merge (cdr xs) ys))))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Problem E
;;
;; (interleave xs ys) returns a single list obtained by choosing
;; elements alternately, first from xs and then from ys, it returns
;; ys if xs is null, otherwise, returns xs if ys is null.

(check-expect (interleave '() '(a b c)) '(a b c)) ;;tests the case with 
;; null xs
(check-expect (interleave '(1 2 3) '()) '(1 2 3)) ;;tests the case with 
;; null ys
(check-expect (interleave '() '()) '()) ;;tests the case with both xs and ys
;; are null
(check-expect (interleave '(1 2 3) '(a b c)) '(1 a 2 b 3 c)) ;;tests the case 
;; with where both xs and ys are the same length
(check-expect (interleave '(1 2 3) '(a b c d e f)) '(1 a 2 b 3 c d e f))
;; tests the case with where ys has more elements than xs
(check-expect (interleave '(1 2 3 4 5 6) '(a b c)) '(1 a 2 b 3 c 4 5 6))
;; tests the case with where xs has more elements than ys


(define interleave (xs ys)
  (if (null? xs)
    ys
    (if (null? ys)
      xs      
      (cons (car xs) (interleave ys (cdr xs))))))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Problem F
;;
;; (remove-one-copy s xs) returns a new list with only one s copy
;; removed, where s is an S-expression and xs is a list which includes
;; one or more copies of that S-expression, it returns xs if s is null,

(check-expect (remove-one-copy '() '(a b c)) '(a b c)) ;;tests the case
;; with null lists
(check-expect (remove-one-copy 'a '(a b c)) '(b c)) ;;tests the case
;; where xs contains one s copy
(check-expect (remove-one-copy 'a '(a a b b c c)) '(a b b c c)) ;;tests the 
;; case where xs contains mutiple s copy
(check-expect (remove-one-copy '(b c) '((a b) (b c) (c d))) '((a b) (c d)))
;;tests the case where s is an list
(check-expect (remove-one-copy 'a '(x y z)) 
'(run-time error:removed-an-absent-item)) ;;tests the case where x is not 
;; in the xs 

;; (elem-contain s xs) return #t if xs contains s, otherwise returns #f, 
;; where s is an s-expression and xs is a list 

(check-expect (elem-contain '() '(a b c)) #t) ;;tests the case
;; with null lists
(check-expect (elem-contain 'a '(a b c)) '#t) ;;tests the case
;; where xs contains one s copy
(check-expect (elem-contain 'd '(a a b b c c)) #f) ;;tests the case
;; where s is not in the xs
(check-expect (elem-contain '(b c) '((a b) (b c) (c d))) #t)
;;tests the case where s is an list 

(define elem-contain (s xs)
  (if (null? s)
    #t
    (if (null? xs)
      #f
      (if (equal? s (car xs))
        #t
        (elem-contain s (cdr xs))))))


;;(elem-remove s xs) returns the the same xs list except s has been removed
;;from xs, where s is an s-expression and xs is a list  

(check-expect (elem-remove '() '(a b c)) '(a b c)) ;;tests the case
;; with null lists
(check-expect (elem-remove 'a '(a b c)) '(b c)) ;;tests the case
;; where xs contains one s copy
(check-expect (elem-remove 'a '(a a b b c c)) '(a b b c c)) ;;tests the case
;; where xs contains mutiple s copy
(check-expect (elem-remove '(b c) '((a b) (b c) (c d))) '((a b) (c d)))
;;tests the case wher 

(define elem-remove (s xs)
  (if (null? s)
    xs
    (if (equal? s (car xs))
      (elem-remove (cdr (list1 s)) (cdr xs))
      (cons (car xs) (elem-remove s (cdr xs))))))


(define remove-one-copy (s xs)
  (if (null? s)
    xs
    (if (elem-contain s xs)
      (elem-remove s xs)
      '(run-time error:removed-an-absent-item))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Problem G
;;
;; (permutation? xs ys) returns #t if xs and ys are permutations
;; (if and only if they have exactly the same elements but possibly
;; in different orders), where xs and ys are two lists otherwise, 
;; returns #f

(check-expect (permutation? '() '(c b a)) #f) ;;tests the case with null xs
(check-expect (permutation? '(a b c) '()) #f) ;;tests the case with null ys
(check-expect (permutation? '() '()) #t) ;;tests the case with both null
(check-expect (permutation? '(a b c) '(c b a)) #t) ;;tests the case where both
;; xs and ys have same elements but in different order
(check-expect (permutation? '(a b b) '(a a b)) #f) ;;tests the case where 
;; xs and ys have different elements
(check-expect (permutation? '(a b c) '(c b a d)) #f) ;;tests the case where
;; the length of ys is bigger than xs
(check-expect (permutation? '(a b c d e) '(b a d)) #f) ;;tests the case where
;; the length of xs is bigger than ys


(define permutation? (xs ys) 
  (if (and (null? xs) (null? ys))
    #t     
    (if (null? xs)
      #f
      (if (null? ys)
        #f   
        (if (elem-contain (car xs) ys)
          (permutation? (cdr xs) (remove-one-copy (car xs) ys))
          #f)))))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Problem H
;;
;; (split-list xs ) returns two lists of nearly equal length
;; by spliting a list xs, differing in length by no more than 
;; one, where xs is a list 

(check-expect (split-list '()) '(() ())) ;;tests the case with empty list
(check-expect (split-list '(1)) '(() (1))) ;;tests the case where xs is a 
;; list contains one element
(check-expect (split-list '(1 2)) '((1) (2))) ;;tests the case where xs is
;; even-length list 
(check-expect (split-list '(1 2 3)) '((2) (3 1))) ;;tests the case where xs
;; is old-length list

;; (split-accumulator xs ys zs) returns two lists evenly accumulate split of 
;; xs, where xs,ys and zs are lists

(check-expect (split-accumulator '() '() '()) '(() ())) ;;tests the case with 
;; empty list
(check-expect (split-accumulator '(1 2 3 4) '() '()) '((3 1) (4 2)))
;;tests the case where xs is not empty list but ys zs are empty lists
(check-expect (split-accumulator '(1 2 3 4) '(6 7) '(8 9 10)) '((3 1 6 7) 
(4 2 8 9 10)))
;;tests the case with no empty lists


(define split-accumulator (xs ys zs)
  (if (null? xs)
    (cons ys (cons zs '()))
    (split-accumulator (cdr xs) zs (cons (car xs) ys))))


(define split-list (xs)
  (split-accumulator xs '() '()))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Problem M
;;
;; (merge-sort xs) returns a sorted version of xs list in increasing
;; order where xs is a list of numbers

(check-expect (merge-sort '()) '()) ;;tests the case with empty xs
(check-expect (merge-sort '(1)) '(1)) ;;tests the case with xs with one 
(check-expect (merge-sort '(189 265 3 10 26 83 20)) '(3 10 20 26 83 189 265))
;;tests the case with old-length xs
(check-expect (merge-sort '(3 72 7 8 9 19 48 1)) '(1 3 7 8 9 19 48 72))
;;tests the case with even-length xs


(define merge-sort (xs)
  (if (null? xs)
    xs
    (if (null? (cdr xs))
      xs
      (let ((s (split-list xs)))
        (let ((a (car s)) (b (car (cdr s)))) 
          (merge (merge-sort a) (merge-sort b)))))))


























